{"ast":null,"code":"// Cullen, Riley\n// ChartDescriptorDecorator.js\n// October 14, 2020\nimport { ABarChartDecorator } from \"./ABarChartDecorator\";\nimport Konva from 'konva';\nimport Lodash from 'lodash';\n\nclass ChartDescriptorDecorator extends ABarChartDecorator {\n  /**\n   * @summary     This decorator adds color descriptors to the chart.\n   * @description Essentially, each bar chart has two elements. Categories \n   *              describe entire bars while subcategories describe the individual\n   *              elements in a bar. In stacked bar charts, these two notions are \n   *              different while in regular bar charts they are the same.\n   * \n   *              With that being said, this decorator class creates a legend\n   *              with each subcategory and its associated color.\n   * \n   * @requires ABarChartDecorator.js\n   * @requires FontWidthDetector.js\n   *  \n   * @param {BarChart}   chart    Chart object we are decorating.\n   * @param {Boolean}    isTop    Determines location of descriptor (top or bottom).\n   * @param {JSON Array} font     Determines font. See CategoryLabelDescriptor\n   *                              for more font information.\n   * @param {int}        iconSize Width/height of descriptor rectangles\n   * \n   */\n  constructor({\n    chart,\n    isTop = true,\n    font = {\n      fontSize: 8,\n      fontFamily: 'Times New Roman, Times, serif',\n      textColor: 'black'\n    },\n    maxPerRow = 3\n  }) {\n    // TODO: vertical vs horizontal descriptor\n    super(chart);\n    this._font = Lodash.cloneDeep(font);\n    this._iconSize = this._chartWidth / 30;\n    this._isTop = isTop;\n    this._maxPerRow = maxPerRow;\n    this._spacing = 20;\n    this._offsetX = 7;\n    this._offsetY = -10;\n  }\n  /**\n   * @summary     This function adds descriptors to the chart.\n   * @description See summary. This function does so by calling _chart's \n   *              CreateBarChart function and _CreateDescriptor.\n   */\n\n\n  CreateChart() {\n    this._chart.CreateChart();\n\n    this._CreateDescriptor();\n  }\n\n  GetDecoratorSettings() {\n    return {\n      chartDescriptor: {\n        font: this._font,\n        location: {\n          isTop: this._isTop\n        },\n        labelSettings: {\n          maxPerRow: this._maxPerRow\n        }\n      }\n    };\n  }\n  /**\n   * @summary     Accessor that changes the value of this._padding.\n   * \n   * @param {double} padding The new padding value we want the chart descriptor \n   *                         to have.\n   */\n\n\n  SetPadding(padding) {\n    this._padding = padding;\n  }\n  /**\n   * @summary     Accessor that changes the value of this._offsetX.\n   * \n   * @param {double} offset The new offsetX value we want the chart descriptor\n   *                        to have.\n   */\n\n\n  SetOffsetX(offset) {\n    this._offsetX = offset;\n  }\n  /**\n   * @summary     Accessor that changes the value of this._offsetY.\n   * \n   * @param {double} offset The new offsetY value we want the chart descriptor\n   *                        to have.\n   */\n\n\n  SetOffsetY(offset) {\n    this._offsetY = offset;\n  }\n  /**\n   * @summary     This function adds descriptors to the chart\n   * @description This function iterates through all of the data and adds\n   *              a descriptor that corresponds to each piece of data.\n   */\n\n\n  _CreateDescriptor() {\n    // TODO: Update dynamic fitting so that instead of constantly decreasing \n    //       font size, after a certain lower bound that descriptors go to the\n    //       'next line'.\n    var helper = new Konva.Group();\n\n    var keys = this._GetSubCategories(),\n        hasPopulated = this._CreateOffsetHelper(keys);\n\n    var startingY = this._isTop ? -(this._iconSize + 30) : this._chartHeight + this._iconSize + 30,\n        cumulativeX = this._xScale(this._data[0].category) + this._offsetX;\n\n    var prevOffset = 0,\n        textOffset = 5,\n        groupOffset = 5;\n    /*while (this._DoesDescriptorExceedWidth(cumulativeX, textOffset) && this._font.fontSize > 6) {\n        this._DecreaseFontSize();\n    }*/\n\n    startingY += this._offsetY;\n\n    this._data.slice().reverse().forEach((d, i) => {\n      if (i % this._maxPerRow === 0 && i !== 0) {\n        startingY += 2 * this._iconSize;\n        cumulativeX = this._xScale(this._data[0].category) + this._offsetX;\n      }\n\n      if (keys.size === 1 || hasPopulated[d.subcategory] === 0) {\n        var textStr = typeof d.subcategory === 'undefined' || d.subcategory === null ? d.category : d.subcategory;\n\n        var textWidth = this._GetFontSize(textStr, this._font);\n\n        var rectX = cumulativeX;\n        var textX = rectX + this._iconSize + textOffset;\n        prevOffset = this._iconSize + textWidth + textOffset;\n        cumulativeX += prevOffset + groupOffset + this._spacing;\n        helper.add(new Konva.Rect({\n          x: rectX,\n          y: startingY,\n          width: this._iconSize,\n          height: this._iconSize,\n          fill: d.color\n        }));\n        var text = new Konva.Text({\n          text: textStr,\n          x: textX,\n          y: startingY,\n          fill: this._font.color,\n          fontSize: this._font.fontSize,\n          fontFamily: this._font.fontFamily\n        });\n        helper.add(text);\n        if (keys.size !== 0) hasPopulated[d.subcategory] = 1;\n      }\n    });\n\n    if (this._rotateBy === 90) {\n      helper.setAttr('x', helper.getAttr('x') - this._chartHeight - this._xScale(this._data[0].category));\n      helper.setAttr('y', helper.getAttr('y') - this._xScale.bandwidth());\n    }\n\n    this._group.add(helper);\n  }\n  /**\n   * @summary     Returns a set of the subcategories found within the data.\n   * @description Maps all of the subcategories found in data to a set.\n   */\n\n\n  _GetSubCategories() {\n    return new Set(this._data.map(d => d.subcategory));\n  }\n  /**\n   * @summary     This function returns if the total with of all the descriptors\n   *              exceeds the total width of the chart\n   * @description See summary. \n   */\n\n\n  _DoesDescriptorExceedWidth(startingX, textOffset) {\n    var totalWidth = startingX;\n\n    this._data.forEach(d => {\n      totalWidth += this._iconSize + this._GetFontSize(d.category, this._font) + textOffset;\n    });\n\n    return totalWidth > this._chartWidth;\n  }\n  /**\n   * @summary     This function decreases the font size by one.\n   * @description See summary.\n   */\n\n\n  _DecreaseFontSize() {\n    this._font.fontSize--;\n  }\n\n}\n\nexport { ChartDescriptorDecorator };","map":{"version":3,"sources":["/Users/mialee/Documents/GitHub/ShareNWWebtool/src/js/Charts/BarChart/Decorators/ChartDescriptorDecorator.js"],"names":["ABarChartDecorator","Konva","Lodash","ChartDescriptorDecorator","constructor","chart","isTop","font","fontSize","fontFamily","textColor","maxPerRow","_font","cloneDeep","_iconSize","_chartWidth","_isTop","_maxPerRow","_spacing","_offsetX","_offsetY","CreateChart","_chart","_CreateDescriptor","GetDecoratorSettings","chartDescriptor","location","labelSettings","SetPadding","padding","_padding","SetOffsetX","offset","SetOffsetY","helper","Group","keys","_GetSubCategories","hasPopulated","_CreateOffsetHelper","startingY","_chartHeight","cumulativeX","_xScale","_data","category","prevOffset","textOffset","groupOffset","slice","reverse","forEach","d","i","size","subcategory","textStr","textWidth","_GetFontSize","rectX","textX","add","Rect","x","y","width","height","fill","color","text","Text","_rotateBy","setAttr","getAttr","bandwidth","_group","Set","map","_DoesDescriptorExceedWidth","startingX","totalWidth","_DecreaseFontSize"],"mappings":"AAAA;AACA;AACA;AAEA,SAASA,kBAAT,QAAmC,sBAAnC;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,QAAnB;;AAEA,MAAMC,wBAAN,SAAuCH,kBAAvC,CACA;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACII,EAAAA,WAAW,CAAC;AAACC,IAAAA,KAAD;AAAQC,IAAAA,KAAK,GAAG,IAAhB;AAAsBC,IAAAA,IAAI,GAAI;AAACC,MAAAA,QAAQ,EAAG,CAAZ;AACtCC,MAAAA,UAAU,EAAG,+BADyB;AAEtCC,MAAAA,SAAS,EAAG;AAF0B,KAA9B;AAEcC,IAAAA,SAAS,GAAG;AAF1B,GAAD,EAGX;AACI;AACA,UAAMN,KAAN;AACA,SAAKO,KAAL,GAAaV,MAAM,CAACW,SAAP,CAAiBN,IAAjB,CAAb;AACA,SAAKO,SAAL,GAAiB,KAAKC,WAAL,GAAmB,EAApC;AACA,SAAKC,MAAL,GAAcV,KAAd;AACA,SAAKW,UAAL,GAAkBN,SAAlB;AACA,SAAKO,QAAL,GAAgB,EAAhB;AACA,SAAKC,QAAL,GAAgB,CAAhB;AACA,SAAKC,QAAL,GAAgB,CAAC,EAAjB;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,WAAW,GACX;AACI,SAAKC,MAAL,CAAYD,WAAZ;;AACA,SAAKE,iBAAL;AACH;;AAEDC,EAAAA,oBAAoB,GACpB;AACI,WAAO;AACHC,MAAAA,eAAe,EAAE;AACblB,QAAAA,IAAI,EAAE,KAAKK,KADE;AAEbc,QAAAA,QAAQ,EAAE;AACNpB,UAAAA,KAAK,EAAE,KAAKU;AADN,SAFG;AAKbW,QAAAA,aAAa,EAAG;AACZhB,UAAAA,SAAS,EAAE,KAAKM;AADJ;AALH;AADd,KAAP;AAWH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIW,EAAAA,UAAU,CAACC,OAAD,EAAU;AAAE,SAAKC,QAAL,GAAgBD,OAAhB;AAA0B;AAEhD;AACJ;AACA;AACA;AACA;AACA;;;AACIE,EAAAA,UAAU,CAACC,MAAD,EAAU;AAAE,SAAKb,QAAL,GAAgBa,MAAhB;AAAyB;AAE/C;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,UAAU,CAACD,MAAD,EAAU;AAAE,SAAKZ,QAAL,GAAgBY,MAAhB;AAAyB;AAE/C;AACJ;AACA;AACA;AACA;;;AACIT,EAAAA,iBAAiB,GACjB;AACI;AACA;AACA;AACA,QAAIW,MAAM,GAAG,IAAIjC,KAAK,CAACkC,KAAV,EAAb;;AACA,QAAIC,IAAI,GAAG,KAAKC,iBAAL,EAAX;AAAA,QAAqCC,YAAY,GAAG,KAAKC,mBAAL,CAAyBH,IAAzB,CAApD;;AACA,QAAII,SAAS,GAAI,KAAKxB,MAAN,GAAgB,EAAE,KAAKF,SAAL,GAAiB,EAAnB,CAAhB,GAAyC,KAAK2B,YAAL,GAAoB,KAAK3B,SAAzB,GAAqC,EAA9F;AAAA,QACI4B,WAAW,GAAG,KAAKC,OAAL,CAAa,KAAKC,KAAL,CAAW,CAAX,EAAcC,QAA3B,IAAuC,KAAK1B,QAD9D;;AAEA,QAAI2B,UAAU,GAAG,CAAjB;AAAA,QAAoBC,UAAU,GAAG,CAAjC;AAAA,QAAoCC,WAAW,GAAG,CAAlD;AAEA;AACR;AACA;;AAEQR,IAAAA,SAAS,IAAI,KAAKpB,QAAlB;;AACA,SAAKwB,KAAL,CAAWK,KAAX,GAAmBC,OAAnB,GAA6BC,OAA7B,CAAqC,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAE3C,UAAKA,CAAC,GAAG,KAAKpC,UAAV,KAA0B,CAA1B,IAA+BoC,CAAC,KAAK,CAAzC,EAA4C;AACxCb,QAAAA,SAAS,IAAI,IAAI,KAAK1B,SAAtB;AACA4B,QAAAA,WAAW,GAAG,KAAKC,OAAL,CAAa,KAAKC,KAAL,CAAW,CAAX,EAAcC,QAA3B,IAAuC,KAAK1B,QAA1D;AACH;;AAED,UAAIiB,IAAI,CAACkB,IAAL,KAAc,CAAd,IAAmBhB,YAAY,CAACc,CAAC,CAACG,WAAH,CAAZ,KAAgC,CAAvD,EAA0D;AACtD,YAAIC,OAAO,GAAI,OAAOJ,CAAC,CAACG,WAAT,KAAyB,WAAzB,IAAwCH,CAAC,CAACG,WAAF,KAAkB,IAA3D,GACRH,CAAC,CAACP,QADM,GACKO,CAAC,CAACG,WADrB;;AAEA,YAAIE,SAAS,GAAG,KAAKC,YAAL,CAAkBF,OAAlB,EAA2B,KAAK5C,KAAhC,CAAhB;;AAEA,YAAI+C,KAAK,GAAGjB,WAAZ;AACA,YAAIkB,KAAK,GAAGD,KAAK,GAAG,KAAK7C,SAAb,GAAyBiC,UAArC;AAEAD,QAAAA,UAAU,GAAG,KAAKhC,SAAL,GAAiB2C,SAAjB,GAA6BV,UAA1C;AACAL,QAAAA,WAAW,IAAII,UAAU,GAAGE,WAAb,GAA2B,KAAK9B,QAA/C;AAEAgB,QAAAA,MAAM,CAAC2B,GAAP,CAAW,IAAI5D,KAAK,CAAC6D,IAAV,CAAe;AACtBC,UAAAA,CAAC,EAAEJ,KADmB;AAEtBK,UAAAA,CAAC,EAAExB,SAFmB;AAGtByB,UAAAA,KAAK,EAAE,KAAKnD,SAHU;AAItBoD,UAAAA,MAAM,EAAE,KAAKpD,SAJS;AAKtBqD,UAAAA,IAAI,EAAEf,CAAC,CAACgB;AALc,SAAf,CAAX;AAOA,YAAIC,IAAI,GAAG,IAAIpE,KAAK,CAACqE,IAAV,CAAe;AACtBD,UAAAA,IAAI,EAAEb,OADgB;AAEtBO,UAAAA,CAAC,EAAEH,KAFmB;AAGtBI,UAAAA,CAAC,EAAExB,SAHmB;AAItB2B,UAAAA,IAAI,EAAE,KAAKvD,KAAL,CAAWwD,KAJK;AAKtB5D,UAAAA,QAAQ,EAAE,KAAKI,KAAL,CAAWJ,QALC;AAMtBC,UAAAA,UAAU,EAAE,KAAKG,KAAL,CAAWH;AAND,SAAf,CAAX;AAQAyB,QAAAA,MAAM,CAAC2B,GAAP,CAAWQ,IAAX;AACA,YAAIjC,IAAI,CAACkB,IAAL,KAAc,CAAlB,EAAqBhB,YAAY,CAACc,CAAC,CAACG,WAAH,CAAZ,GAA8B,CAA9B;AACxB;AACJ,KApCD;;AAsCA,QAAI,KAAKgB,SAAL,KAAmB,EAAvB,EAA2B;AACvBrC,MAAAA,MAAM,CAACsC,OAAP,CAAe,GAAf,EAAoBtC,MAAM,CAACuC,OAAP,CAAe,GAAf,IAAsB,KAAKhC,YAA3B,GAA0C,KAAKE,OAAL,CAAa,KAAKC,KAAL,CAAW,CAAX,EAAcC,QAA3B,CAA9D;AACAX,MAAAA,MAAM,CAACsC,OAAP,CAAe,GAAf,EAAoBtC,MAAM,CAACuC,OAAP,CAAe,GAAf,IAAsB,KAAK9B,OAAL,CAAa+B,SAAb,EAA1C;AACH;;AAED,SAAKC,MAAL,CAAYd,GAAZ,CAAgB3B,MAAhB;AACH;AAED;AACJ;AACA;AACA;;;AACIG,EAAAA,iBAAiB,GACjB;AACI,WAAO,IAAIuC,GAAJ,CAAQ,KAAKhC,KAAL,CAAWiC,GAAX,CAAezB,CAAC,IAAIA,CAAC,CAACG,WAAtB,CAAR,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACIuB,EAAAA,0BAA0B,CAACC,SAAD,EAAYhC,UAAZ,EAC1B;AACI,QAAIiC,UAAU,GAAGD,SAAjB;;AACA,SAAKnC,KAAL,CAAWO,OAAX,CAAmBC,CAAC,IAAI;AACpB4B,MAAAA,UAAU,IAAK,KAAKlE,SAAL,GAAiB,KAAK4C,YAAL,CAAkBN,CAAC,CAACP,QAApB,EAA8B,KAAKjC,KAAnC,CAAjB,GAA6DmC,UAA5E;AACH,KAFD;;AAGA,WAAOiC,UAAU,GAAG,KAAKjE,WAAzB;AACH;AAED;AACJ;AACA;AACA;;;AACIkE,EAAAA,iBAAiB,GACjB;AACI,SAAKrE,KAAL,CAAWJ,QAAX;AACH;;AAvLL;;AA0LA,SAASL,wBAAT","sourcesContent":["// Cullen, Riley\n// ChartDescriptorDecorator.js\n// October 14, 2020\n\nimport { ABarChartDecorator } from \"./ABarChartDecorator\";\nimport Konva from 'konva';\nimport Lodash from 'lodash';\n\nclass ChartDescriptorDecorator extends ABarChartDecorator\n{\n    /**\n     * @summary     This decorator adds color descriptors to the chart.\n     * @description Essentially, each bar chart has two elements. Categories \n     *              describe entire bars while subcategories describe the individual\n     *              elements in a bar. In stacked bar charts, these two notions are \n     *              different while in regular bar charts they are the same.\n     * \n     *              With that being said, this decorator class creates a legend\n     *              with each subcategory and its associated color.\n     * \n     * @requires ABarChartDecorator.js\n     * @requires FontWidthDetector.js\n     *  \n     * @param {BarChart}   chart    Chart object we are decorating.\n     * @param {Boolean}    isTop    Determines location of descriptor (top or bottom).\n     * @param {JSON Array} font     Determines font. See CategoryLabelDescriptor\n     *                              for more font information.\n     * @param {int}        iconSize Width/height of descriptor rectangles\n     * \n     */\n    constructor({chart, isTop = true, font =  {fontSize : 8, \n        fontFamily : 'Times New Roman, Times, serif', \n        textColor : 'black'}, maxPerRow = 3}) \n    {\n        // TODO: vertical vs horizontal descriptor\n        super(chart);\n        this._font = Lodash.cloneDeep(font);\n        this._iconSize = this._chartWidth / 30;\n        this._isTop = isTop;\n        this._maxPerRow = maxPerRow;\n        this._spacing = 20;\n        this._offsetX = 7;\n        this._offsetY = -10;\n    }\n\n    /**\n     * @summary     This function adds descriptors to the chart.\n     * @description See summary. This function does so by calling _chart's \n     *              CreateBarChart function and _CreateDescriptor.\n     */\n    CreateChart()\n    {\n        this._chart.CreateChart();\n        this._CreateDescriptor();\n    }\n\n    GetDecoratorSettings() \n    {\n        return {\n            chartDescriptor: {\n                font: this._font,\n                location: {\n                    isTop: this._isTop,\n                },\n                labelSettings : {\n                    maxPerRow: this._maxPerRow,\n                }\n            }\n        }\n    }\n\n    /**\n     * @summary     Accessor that changes the value of this._padding.\n     * \n     * @param {double} padding The new padding value we want the chart descriptor \n     *                         to have.\n     */\n    SetPadding(padding) { this._padding = padding; }\n\n    /**\n     * @summary     Accessor that changes the value of this._offsetX.\n     * \n     * @param {double} offset The new offsetX value we want the chart descriptor\n     *                        to have.\n     */\n    SetOffsetX(offset)  { this._offsetX = offset; }\n\n    /**\n     * @summary     Accessor that changes the value of this._offsetY.\n     * \n     * @param {double} offset The new offsetY value we want the chart descriptor\n     *                        to have.\n     */\n    SetOffsetY(offset)  { this._offsetY = offset; }\n\n    /**\n     * @summary     This function adds descriptors to the chart\n     * @description This function iterates through all of the data and adds\n     *              a descriptor that corresponds to each piece of data.\n     */\n    _CreateDescriptor()\n    {\n        // TODO: Update dynamic fitting so that instead of constantly decreasing \n        //       font size, after a certain lower bound that descriptors go to the\n        //       'next line'.\n        var helper = new Konva.Group();\n        var keys = this._GetSubCategories(), hasPopulated = this._CreateOffsetHelper(keys);\n        var startingY = (this._isTop) ? -(this._iconSize + 30) : this._chartHeight + this._iconSize + 30, \n            cumulativeX = this._xScale(this._data[0].category) + this._offsetX;\n        var prevOffset = 0, textOffset = 5, groupOffset = 5;\n\n        /*while (this._DoesDescriptorExceedWidth(cumulativeX, textOffset) && this._font.fontSize > 6) {\n            this._DecreaseFontSize();\n        }*/\n\n        startingY += this._offsetY;\n        this._data.slice().reverse().forEach((d, i) => {\n\n            if ((i % this._maxPerRow) === 0 && i !== 0) {\n                startingY += 2 * this._iconSize;\n                cumulativeX = this._xScale(this._data[0].category) + this._offsetX;\n            }\n            \n            if (keys.size === 1 || hasPopulated[d.subcategory] === 0) {\n                var textStr = (typeof d.subcategory === 'undefined' || d.subcategory === null)\n                    ? d.category : d.subcategory;\n                var textWidth = this._GetFontSize(textStr, this._font);\n\n                var rectX = cumulativeX;\n                var textX = rectX + this._iconSize + textOffset;\n\n                prevOffset = this._iconSize + textWidth + textOffset;\n                cumulativeX += prevOffset + groupOffset + this._spacing;\n\n                helper.add(new Konva.Rect({\n                    x: rectX,\n                    y: startingY,\n                    width: this._iconSize,\n                    height: this._iconSize,\n                    fill: d.color,\n                }));\n                var text = new Konva.Text({\n                    text: textStr,\n                    x: textX,\n                    y: startingY,\n                    fill: this._font.color,\n                    fontSize: this._font.fontSize,\n                    fontFamily: this._font.fontFamily,\n                });\n                helper.add(text);\n                if (keys.size !== 0) hasPopulated[d.subcategory] = 1;\n            }\n        });\n\n        if (this._rotateBy === 90) {\n            helper.setAttr('x', helper.getAttr('x') - this._chartHeight - this._xScale(this._data[0].category));\n            helper.setAttr('y', helper.getAttr('y') - this._xScale.bandwidth());\n        }\n\n        this._group.add(helper);\n    }\n\n    /**\n     * @summary     Returns a set of the subcategories found within the data.\n     * @description Maps all of the subcategories found in data to a set.\n     */\n    _GetSubCategories()\n    {\n        return new Set(this._data.map(d => d.subcategory));\n    }\n\n    /**\n     * @summary     This function returns if the total with of all the descriptors\n     *              exceeds the total width of the chart\n     * @description See summary. \n     */\n    _DoesDescriptorExceedWidth(startingX, textOffset)\n    {\n        var totalWidth = startingX;\n        this._data.forEach(d => {\n            totalWidth += (this._iconSize + this._GetFontSize(d.category, this._font) + textOffset);\n        }); \n        return totalWidth > this._chartWidth;\n    }\n\n    /**\n     * @summary     This function decreases the font size by one.\n     * @description See summary.\n     */\n    _DecreaseFontSize()\n    {\n        this._font.fontSize--;\n    }\n}\n\nexport { ChartDescriptorDecorator };"]},"metadata":{},"sourceType":"module"}