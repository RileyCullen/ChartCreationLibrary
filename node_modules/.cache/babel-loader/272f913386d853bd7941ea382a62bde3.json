{"ast":null,"code":"import * as d3 from 'd3';\n\nclass AIconBar {\n  constructor({\n    data,\n    group,\n    width,\n    height,\n    padding,\n    angleOffset = 0,\n    icon = '\\uf183',\n    remainderColor = 'black',\n    iconSize = 100,\n    dynamicFont = false\n  }) {\n    if (this.constructor === AIconBar) {\n      throw new TypeError('Abstract class \"ABarChart\" cannot be instantiated');\n    }\n\n    if (this.CreateChart === undefined) {\n      throw new TypeError('Classes extending ABarChart must implement \"CreateBarChart\"');\n    }\n\n    this._data = data;\n    this._group = group;\n    this._chartWidth = width;\n    this._chartHeight = height;\n    this._padding = padding;\n    this._angleOffset = angleOffset;\n    this._icon = icon;\n    this._remainderColor = remainderColor;\n    this._iconSize = parseFloat(iconSize);\n    this._dynamicFont = dynamicFont;\n    this._xScale = d3.scaleBand().range([0, this._chartWidth]).padding(this._padding);\n    this._yScale = d3.scaleLinear().range([this._chartHeight, 0]);\n\n    this._SetUpXDomain();\n\n    this._SetUpYDomain();\n  }\n  /**\n   * @summary     Returns the data bound to a particular BarChart type.\n   * @description Returns the JSON array named _data to the caller. Note that \n   *              this returns a reference to the actual data element and not \n   *              a copy.\n   */\n\n\n  GetData() {\n    return this._data;\n  }\n\n  GetChartSettings() {\n    return {\n      iconSettings: {\n        iconColor: this._remainderColor,\n        iconSize: this._iconSize,\n        padding: this._padding\n      }\n    };\n  }\n  /**\n   * @summary     Updates data array.\n   * @description Updates data array as well as the yScale since a given BarChart's\n   *              yScale is determined by the data. Note that the data array \n   *              passed into this function should follow the form:\n   * \n   *              data[i] = {\n   *                  'category': 'categoryName',\n   *                  'value': value,\n   *                  'color: color, \n   *              }. \n   * \n   *              Also note that this function does not make any effort to \n   *              verify that the data array passed in is valid and assumes by\n   *              contract that it is so.            \n   * \n   * @param {JSON Array} data The new data array we want to bind to our \n   *                          BarChart object.\n   */\n\n\n  UpdateData(data) {\n    this._Clean();\n\n    this._data = data;\n\n    this._SetUpYDomain();\n\n    this._SetUpXDomain();\n  }\n\n  UpdateChartSettings(settings) {\n    this._remainderColor = settings.iconSettings.iconColor;\n    this._iconSize = settings.iconSettings.iconSize;\n    this._padding = settings.iconSettings.padding;\n\n    this._group.destroyChildren();\n  }\n  /**\n   * @summary     Removes the bar chart from the canvas. \n   * @description A wrapper function that calls the Konva.js method destroy(),\n   *              which removes the group from the Konva.Stage.\n   */\n\n\n  Remove() {\n    this._group.destroy();\n  }\n  /**\n   * @summary     Removes all child nodes in this group.\n   * @description A wrapper function that calls the Konva.js method \n   *              destroyChildren() which removes all of the child elements \n   *              located with _group.\n   */\n\n\n  _Clean() {\n    this._group.destroyChildren();\n  }\n  /**\n   * @summary     This function sets up the xScale's domain.\n   * @description This function sets up the xScale's domain by mapping \n   *              each of the categories within the data array to a place\n   *              in the domain.\n   */\n\n\n  _SetUpXDomain() {\n    this._xScale.domain(this._data.map(d => {\n      return d.category;\n    }));\n  }\n  /**\n   * @summary     This function sets up the yScale's domain.\n   * @description This function dests up the yScale's domain by assigning \n   *              a lower bound of 0 and an upper bound that corresponds \n   *              to the maximum value within the data array.\n   */\n\n\n  _SetUpYDomain() {\n    var keys = this.GetGroups(),\n        tmp = this._CreateOffsetHelper(keys);\n\n    this._data.forEach(d => {\n      tmp[d.category] += parseInt(d.value);\n    });\n\n    var max = this._FindMax(tmp, keys);\n\n    this._yScale.domain([0, max]);\n  }\n  /**\n   * @summary     Finds the max value in the data array.\n   * @description Function that iterates through a set of values created from\n   *              _data. This function attempts to find the max value in _data.\n   * \n   * @param {} arr \n   * @param {*} keys \n   */\n\n\n  _FindMax(arr, keys) {\n    const iter = keys.values();\n    var max = 0;\n\n    for (var i = iter.next().value; i != null; i = iter.next().value) {\n      if (arr[i] > max) max = arr[i];\n    }\n\n    return max;\n  }\n\n  _FindMinCategory() {\n    var index = 0;\n\n    for (var i = 1; i < this._data.length; i++) {\n      if (this._data[index].value > this._data[i].value) index = i;\n    }\n\n    return this._data[index].category;\n  }\n  /**\n   * @summary     Returns a set of categories.\n   * @description Creates a new set and maps each of the categories to a value\n   *              within the set.\n   */\n\n\n  GetGroups() {\n    return new Set(this._data.map(d => d.category));\n  }\n  /**\n   * @summary     Creates an array where the keys are all of the categories found \n   *              in the data array.\n   * @description See summary. This allows us to offset the stacked bars in a \n   *              stacked bar chart.\n   * \n   * @param {Set} keys A set of unique categories that allows us to create the \n   *                   offset helper array.\n   */\n\n\n  _CreateOffsetHelper(keys) {\n    var tmp = [];\n    const iter = keys.values();\n\n    for (var i = 0; i < keys.size; i++) {\n      tmp[iter.next().value] = 0;\n    }\n\n    return tmp;\n  }\n\n}\n\nexport { AIconBar };","map":{"version":3,"sources":["/Users/mialee/Documents/GitHub/ShareNWWebtool/src/js/Charts/IconBarChart/AIconBar.js"],"names":["d3","AIconBar","constructor","data","group","width","height","padding","angleOffset","icon","remainderColor","iconSize","dynamicFont","TypeError","CreateChart","undefined","_data","_group","_chartWidth","_chartHeight","_padding","_angleOffset","_icon","_remainderColor","_iconSize","parseFloat","_dynamicFont","_xScale","scaleBand","range","_yScale","scaleLinear","_SetUpXDomain","_SetUpYDomain","GetData","GetChartSettings","iconSettings","iconColor","UpdateData","_Clean","UpdateChartSettings","settings","destroyChildren","Remove","destroy","domain","map","d","category","keys","GetGroups","tmp","_CreateOffsetHelper","forEach","parseInt","value","max","_FindMax","arr","iter","values","i","next","_FindMinCategory","index","length","Set","size"],"mappings":"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","sourcesContent":["import * as d3 from 'd3';\n\nclass AIconBar \n{\n    constructor({data, group, width, height, padding, angleOffset = 0,\n        icon = '\\uf183', remainderColor = 'black', iconSize = 100, dynamicFont = false})\n    {\n        if (this.constructor === AIconBar) {\n            throw new TypeError('Abstract class \"ABarChart\" cannot be instantiated');\n        }\n\n        if (this.CreateChart === undefined) {\n            throw new TypeError('Classes extending ABarChart must implement \"CreateBarChart\"');\n        }\n\n        this._data = data;\n        this._group = group;\n        this._chartWidth = width;\n        this._chartHeight = height;\n        this._padding = padding;\n        this._angleOffset = angleOffset;\n        this._icon = icon;\n        this._remainderColor = remainderColor;\n        this._iconSize = parseFloat(iconSize);\n        this._dynamicFont = dynamicFont;\n\n        this._xScale = d3.scaleBand()\n            .range([0, this._chartWidth])\n            .padding(this._padding);\n        this._yScale = d3.scaleLinear()\n            .range([this._chartHeight, 0]);\n\n        this._SetUpXDomain();\n        this._SetUpYDomain();\n    }\n    /**\n     * @summary     Returns the data bound to a particular BarChart type.\n     * @description Returns the JSON array named _data to the caller. Note that \n     *              this returns a reference to the actual data element and not \n     *              a copy.\n     */\n     GetData()\n     {\n         return this._data;\n     }\n\n    GetChartSettings()\n    {\n        return {\n            iconSettings: {\n                iconColor: this._remainderColor,\n                iconSize: this._iconSize,\n                padding: this._padding, \n            }\n        }\n    }\n \n     /**\n      * @summary     Updates data array.\n      * @description Updates data array as well as the yScale since a given BarChart's\n      *              yScale is determined by the data. Note that the data array \n      *              passed into this function should follow the form:\n      * \n      *              data[i] = {\n      *                  'category': 'categoryName',\n      *                  'value': value,\n      *                  'color: color, \n      *              }. \n      * \n      *              Also note that this function does not make any effort to \n      *              verify that the data array passed in is valid and assumes by\n      *              contract that it is so.            \n      * \n      * @param {JSON Array} data The new data array we want to bind to our \n      *                          BarChart object.\n      */\n     UpdateData(data)\n     {\n         this._Clean();\n         this._data = data;\n         this._SetUpYDomain();\n         this._SetUpXDomain();\n     }\n\n    UpdateChartSettings(settings)\n    {\n        this._remainderColor = settings.iconSettings.iconColor;\n        this._iconSize = settings.iconSettings.iconSize;\n        this._padding = settings.iconSettings.padding;\n\n        this._group.destroyChildren();\n    }     \n\n     /**\n      * @summary     Removes the bar chart from the canvas. \n      * @description A wrapper function that calls the Konva.js method destroy(),\n      *              which removes the group from the Konva.Stage.\n      */\n     Remove()\n     {\n         this._group.destroy();\n     }\n \n     /**\n      * @summary     Removes all child nodes in this group.\n      * @description A wrapper function that calls the Konva.js method \n      *              destroyChildren() which removes all of the child elements \n      *              located with _group.\n      */\n     _Clean()\n     {\n         this._group.destroyChildren();\n     }\n \n     /**\n      * @summary     This function sets up the xScale's domain.\n      * @description This function sets up the xScale's domain by mapping \n      *              each of the categories within the data array to a place\n      *              in the domain.\n      */\n     _SetUpXDomain()\n     {\n         this._xScale.domain(this._data.map(d => { return d.category; }));\n     }\n \n     /**\n      * @summary     This function sets up the yScale's domain.\n      * @description This function dests up the yScale's domain by assigning \n      *              a lower bound of 0 and an upper bound that corresponds \n      *              to the maximum value within the data array.\n      */\n     _SetUpYDomain()\n     {\n         var keys = this.GetGroups(), tmp = this._CreateOffsetHelper(keys);\n \n         this._data.forEach(d => {\n             tmp[d.category] += parseInt(d.value);\n         });\n \n         var max = this._FindMax(tmp, keys);\n \n         this._yScale.domain([0, max]);\n     }\n \n     /**\n      * @summary     Finds the max value in the data array.\n      * @description Function that iterates through a set of values created from\n      *              _data. This function attempts to find the max value in _data.\n      * \n      * @param {} arr \n      * @param {*} keys \n      */\n     _FindMax(arr, keys)\n     {\n         const iter = keys.values();\n         var max = 0;\n         for (var i = iter.next().value; i != null; i = iter.next().value) {\n             if (arr[i] > max) max = arr[i];\n         }\n         return max;\n     }\n \n     _FindMinCategory()\n     {\n         var index = 0;\n         for (var i = 1; i < this._data.length; i++) {\n             if (this._data[index].value > this._data[i].value) index = i;\n         }\n         return this._data[index].category;\n     }\n     \n \n     /**\n      * @summary     Returns a set of categories.\n      * @description Creates a new set and maps each of the categories to a value\n      *              within the set.\n      */\n     GetGroups()\n     {\n         return new Set(this._data.map(d => d.category));\n     }\n \n     /**\n      * @summary     Creates an array where the keys are all of the categories found \n      *              in the data array.\n      * @description See summary. This allows us to offset the stacked bars in a \n      *              stacked bar chart.\n      * \n      * @param {Set} keys A set of unique categories that allows us to create the \n      *                   offset helper array.\n      */\n     _CreateOffsetHelper(keys)\n     {\n         var tmp = [];\n         const iter = keys.values();\n         for (var i = 0; i < keys.size; i++) {\n             tmp[iter.next().value] = 0;\n         }\n         return tmp;\n     }\n}\n\nexport { AIconBar };"]},"metadata":{},"sourceType":"module"}