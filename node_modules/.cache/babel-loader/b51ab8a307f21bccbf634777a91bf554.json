{"ast":null,"code":"// Riley Cullen\n// IconBarChart.js\n// Lasted Updated: May 31, 2021\nimport * as d3 from 'd3';\nimport Konva from 'konva';\nimport { AIconBar } from '../AIconBar';\n\nclass IconBarChart extends AIconBar {\n  /**\n   * @summary     A concrete bar chart type that creates a \"bar\" chart with\n   *              icons in place of the bars.\n   * @description A concrete bar chart type that uses icons from FontAwesome\n   *              and the Konva.Text module to create icon bar charts. \n   *              Essentially, the icons are created using Konva.Text elements\n   *              and a linear gradient is applied too the text element to \n   *              simulate the \"bar\" in a bar chart.\n   * \n   * @see ABarChart for documentation on data, group, width, height, and padding.\n   * @param {string} icon           The icon that will be displayed on the chart.\n   * @param {string} remainderColor The color of the remaining space in the \n   *                                icon. For example, if half an icon is \n   *                                to be colored blue and remainderColor is \n   *                                set to 'white', then the remaining half\n   *                                will be colored white.\n   * @param {double} iconSize       The size of the icon.\n   * @param {bool}   dynamicFont    A boolean that determines if the icons \n   *                                will be dynamically resized based on \n   *                                the given chart width.\n   *  \n   */\n  constructor({\n    data,\n    group,\n    width,\n    height,\n    padding,\n    angleOffset = 0,\n    icon = '\\uf183',\n    remainderColor = 'black',\n    iconSize = 100,\n    dynamicFont = false\n  }) {\n    super({\n      data: data,\n      group: group,\n      width: width,\n      height: height,\n      padding: padding,\n      angleOffset: angleOffset,\n      icon: icon,\n      remainderColor: remainderColor,\n      iconSize: iconSize,\n      dynamicFont: dynamicFont\n    });\n  }\n  /**\n   * @summary     A method that draws the icon bar chart on canvas.\n   * @description A method that creates the icon bar chart by first binding \n   *              the data within _data to custom DOM elements and the using \n   *              that data to draw canvas elements using Konva.js\n   */\n\n\n  CreateChart() {\n    if (this._dynamicFont) this._DetermineFontSize();\n\n    var upperBound = this._UpdateUpperBound();\n\n    var virtualCanvas = document.createElement('custom');\n    var custom = d3.select(virtualCanvas);\n\n    this._BindData(custom);\n\n    var points = this._DetermineLinearGradient(upperBound);\n\n    this._Draw(custom, points);\n  }\n  /**\n   * @summary     This function finds the max height, or upper bound, of the\n   *              icon.\n   * @description This returns the max height of the icon to the caller. An\n   *              upper bound is necessary because it allows us to set an accurate\n   *              start point for our linear gradient.\n   * @returns An integer representing the upperBound of our icon.\n   */\n\n\n  _UpdateUpperBound() {\n    var upperBound = this._iconSize;\n    return parseInt(upperBound);\n  }\n  /**\n   * @summary     Returns an array of points for the linear gradient.\n   * @description Creates an array of JSON objects that represent the start\n   *              and end points of the linear gradient we will use to simulate \n   *              the bars in a bar chart. \n   * \n   * @param {double} upperBound The height of the icon.\n   * @returns An array of JSON objects representing the start and end points of\n   *          a linear gradient.\n   */\n\n\n  _DetermineLinearGradient(upperBound) {\n    // Note that we add one to the start and end points as \"padding.\" Without \n    // it, some icons will have extra white space surrounding the actual linear \n    // gradient.\n    return [{\n      x: 0,\n      y: upperBound + 1\n    }, {\n      x: 0,\n      y: -1\n    }];\n  }\n  /**\n   * @summary     Finds the max value in _data.\n   * @description Iterates through _data and returns the max value.\n   * @returns     The max value.\n   */\n\n\n  _FindMaxValue() {\n    var max = this._data.length > 0 ? this._data[0].value : 0;\n\n    for (var i = 1; i < this._data.length; i++) {\n      if (this._data[i].value > max) max = this._data[i].value;\n    }\n\n    return max;\n  }\n  /**\n   * @summary     Binds data to custom DOM elements using D3.\n   * @description Creates custom DOM elements, accessible through custom,\n   *              and binds data to those elements for use later.\n   * \n   * @param {DOM Element} custom The container of our custom DOM elements.\n   */\n\n\n  _BindData(custom) {\n    var minCategory = this._FindMinCategory();\n\n    custom.selectAll('custom.elem').data(this._data).enter().append('custom').attr('class', 'elem').attr('x', (d, i) => {\n      /**\n       * NOTE that here, we subtract the xScale of minCategory so that\n       * the first icon starts at 0. In addition, we add offset to account \n       * for the padding set by the user.\n       */\n      var offset = i === 0 ? 0 : parseFloat(this._padding);\n      return this._xScale(d.category) - this._xScale(minCategory) + i * offset;\n    }).attr('y', () => {\n      // Update to use text metrics to find height\n      return this._iconSize / 2;\n    }).attr('width', () => {\n      return this._xScale.bandwidth();\n    }).attr('gradientHeight', d => {\n      /**\n       * This value will determine the height of the gradient. Essentially,\n       * we find the max value in _data and then use the proportion of \n       * the current value out of this max value to find the point at which\n       * the gradient changes from its intended color to the remainder\n       * color. This value needs to be between 0 and 1.\n       */\n      return d.value / this._FindMaxValue();\n    }).attr('fillStyle', d => {\n      return d.color;\n    }).attr('icon', this._icon).attr('remainderColor', this._remainderColor).attr('size', this._iconSize).attr('angleOffset', this._angleOffset);\n  }\n  /**\n   * @summary     Finds the category with the smallest value in _data.\n   * @description Iterates through _data and returns the category name corresponding\n   *              to the smallest value.\n   * @returns     A string representing the category with the smallest value.\n   */\n\n\n  _FindMinCategory() {\n    var index = 0;\n\n    for (var i = 1; i < this._data.length; i++) {\n      if (this._data[index].value > this._data[i].value) index = i;\n    }\n\n    return this._data[index].category;\n  }\n  /**\n   * @summary     Draws bar chart on canvas.\n   * @description Uses data bound in custom to draw icons to canvas using Konva.JS.\n   * \n   * @param {DOM Element} custom The container for our custom DOM elements.\n   * @param {JSON Array}  points The start and end points for our linear gradient.\n   */\n\n\n  _Draw(custom, points) {\n    var elements = custom.selectAll('custom.elem');\n    var helper = new Konva.Group({\n      x: 0,\n      y: 0\n    });\n    elements.each(function () {\n      var node = d3.select(this);\n      var gradientHeight = parseFloat(node.attr('gradientHeight')),\n          iconSize = parseFloat(node.attr('size')),\n          x = parseFloat(node.attr('x')),\n          y = parseFloat(node.attr('y'));\n      console.log('x: ' + x);\n      var icon = new Konva.Text({\n        text: node.attr('icon'),\n        fontSize: iconSize,\n        fontFamily: '\"Font Awesome 5 Free\"',\n        fontStyle: '900',\n        x: x,\n        y: y,\n        fillLinearGradientStartPoint: points[0],\n        fillLinearGradientEndPoint: points[1],\n        fillLinearGradientColorStops: [0, node.attr('fillStyle'), gradientHeight, node.attr('fillStyle'), gradientHeight, node.attr('remainderColor'), 1, node.attr('remainderColor')]\n      });\n      icon.rotate(-node.attr('angleOffset'));\n      helper.add(icon);\n    });\n\n    this._group.add(helper);\n  }\n\n}\n\nexport { IconBarChart };","map":{"version":3,"sources":["/Users/mialee/Documents/GitHub/ShareNWWebtool/src/js/Charts/IconBarChart/ConcreteCharts/IconBarChart.js"],"names":["d3","Konva","AIconBar","IconBarChart","constructor","data","group","width","height","padding","angleOffset","icon","remainderColor","iconSize","dynamicFont","CreateChart","_dynamicFont","_DetermineFontSize","upperBound","_UpdateUpperBound","virtualCanvas","document","createElement","custom","select","_BindData","points","_DetermineLinearGradient","_Draw","_iconSize","parseInt","x","y","_FindMaxValue","max","_data","length","value","i","minCategory","_FindMinCategory","selectAll","enter","append","attr","d","offset","parseFloat","_padding","_xScale","category","bandwidth","color","_icon","_remainderColor","_angleOffset","index","elements","helper","Group","each","node","gradientHeight","console","log","Text","text","fontSize","fontFamily","fontStyle","fillLinearGradientStartPoint","fillLinearGradientEndPoint","fillLinearGradientColorStops","rotate","add","_group"],"mappings":"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","sourcesContent":["// Riley Cullen\n// IconBarChart.js\n// Lasted Updated: May 31, 2021\n\nimport * as d3 from 'd3';\nimport Konva from 'konva';\nimport { AIconBar } from '../AIconBar';\n\nclass IconBarChart extends AIconBar\n{\n    /**\n     * @summary     A concrete bar chart type that creates a \"bar\" chart with\n     *              icons in place of the bars.\n     * @description A concrete bar chart type that uses icons from FontAwesome\n     *              and the Konva.Text module to create icon bar charts. \n     *              Essentially, the icons are created using Konva.Text elements\n     *              and a linear gradient is applied too the text element to \n     *              simulate the \"bar\" in a bar chart.\n     * \n     * @see ABarChart for documentation on data, group, width, height, and padding.\n     * @param {string} icon           The icon that will be displayed on the chart.\n     * @param {string} remainderColor The color of the remaining space in the \n     *                                icon. For example, if half an icon is \n     *                                to be colored blue and remainderColor is \n     *                                set to 'white', then the remaining half\n     *                                will be colored white.\n     * @param {double} iconSize       The size of the icon.\n     * @param {bool}   dynamicFont    A boolean that determines if the icons \n     *                                will be dynamically resized based on \n     *                                the given chart width.\n     *  \n     */\n    constructor({data, group, width, height, padding, angleOffset = 0,\n        icon = '\\uf183', remainderColor = 'black', iconSize = 100, dynamicFont = false})\n    {\n        super({\n            data: data,\n            group: group,\n            width: width,\n            height: height,\n            padding: padding,\n            angleOffset: angleOffset,\n            icon: icon,\n            remainderColor: remainderColor,\n            iconSize: iconSize,\n            dynamicFont: dynamicFont,\n        });\n    }\n\n    /**\n     * @summary     A method that draws the icon bar chart on canvas.\n     * @description A method that creates the icon bar chart by first binding \n     *              the data within _data to custom DOM elements and the using \n     *              that data to draw canvas elements using Konva.js\n     */\n    CreateChart()\n    {\n        if (this._dynamicFont) this._DetermineFontSize();\n        var upperBound = this._UpdateUpperBound();\n        \n        var virtualCanvas = document.createElement('custom');\n        var custom = d3.select(virtualCanvas);\n\n        this._BindData(custom) \n\n        var points = this._DetermineLinearGradient(upperBound);\n        this._Draw(custom, points);\n    }\n\n    /**\n     * @summary     This function finds the max height, or upper bound, of the\n     *              icon.\n     * @description This returns the max height of the icon to the caller. An\n     *              upper bound is necessary because it allows us to set an accurate\n     *              start point for our linear gradient.\n     * @returns An integer representing the upperBound of our icon.\n     */\n    _UpdateUpperBound()\n    {\n        var upperBound = this._iconSize;\n        return parseInt(upperBound);\n    }\n\n    /**\n     * @summary     Returns an array of points for the linear gradient.\n     * @description Creates an array of JSON objects that represent the start\n     *              and end points of the linear gradient we will use to simulate \n     *              the bars in a bar chart. \n     * \n     * @param {double} upperBound The height of the icon.\n     * @returns An array of JSON objects representing the start and end points of\n     *          a linear gradient.\n     */\n    _DetermineLinearGradient(upperBound)\n    {\n        // Note that we add one to the start and end points as \"padding.\" Without \n        // it, some icons will have extra white space surrounding the actual linear \n        // gradient.\n        return [\n            { x: 0, y: upperBound + 1},\n            { x: 0, y: -1 }\n        ];\n    }\n\n    /**\n     * @summary     Finds the max value in _data.\n     * @description Iterates through _data and returns the max value.\n     * @returns     The max value.\n     */\n    _FindMaxValue()\n    {\n        var max = (this._data.length > 0) ? this._data[0].value : 0;\n        for (var i = 1; i < this._data.length; i++) {\n            if (this._data[i].value > max) max = this._data[i].value;\n        }\n        return max;\n    }\n\n    /**\n     * @summary     Binds data to custom DOM elements using D3.\n     * @description Creates custom DOM elements, accessible through custom,\n     *              and binds data to those elements for use later.\n     * \n     * @param {DOM Element} custom The container of our custom DOM elements.\n     */\n    _BindData(custom)\n    {\n        var minCategory = this._FindMinCategory();\n        custom.selectAll('custom.elem')\n            .data(this._data)\n            .enter()\n            .append('custom')\n            .attr('class', 'elem')\n            .attr('x', (d, i) => {\n                /**\n                 * NOTE that here, we subtract the xScale of minCategory so that\n                 * the first icon starts at 0. In addition, we add offset to account \n                 * for the padding set by the user.\n                 */\n                var offset = (i === 0) ? 0 : parseFloat(this._padding);\n                return this._xScale(d.category) - this._xScale(minCategory) + i * offset;\n            })\n            .attr('y', () => {\n                // Update to use text metrics to find height\n                return (this._iconSize / 2);\n            })\n            .attr('width', () => {\n                return this._xScale.bandwidth();\n            })\n            .attr('gradientHeight', (d) => {\n                /**\n                 * This value will determine the height of the gradient. Essentially,\n                 * we find the max value in _data and then use the proportion of \n                 * the current value out of this max value to find the point at which\n                 * the gradient changes from its intended color to the remainder\n                 * color. This value needs to be between 0 and 1.\n                 */\n                return d.value / this._FindMaxValue();\n            })\n            .attr('fillStyle', (d) => {\n                return d.color;\n            })\n            .attr('icon', this._icon)\n            .attr('remainderColor', this._remainderColor)\n            .attr('size', this._iconSize)\n            .attr('angleOffset', this._angleOffset);\n    }\n\n    /**\n     * @summary     Finds the category with the smallest value in _data.\n     * @description Iterates through _data and returns the category name corresponding\n     *              to the smallest value.\n     * @returns     A string representing the category with the smallest value.\n     */\n    _FindMinCategory()\n    {\n        var index = 0;\n        for (var i = 1; i < this._data.length; i++) {\n            if (this._data[index].value > this._data[i].value) index = i;\n        }\n        return this._data[index].category;\n    }\n\n    /**\n     * @summary     Draws bar chart on canvas.\n     * @description Uses data bound in custom to draw icons to canvas using Konva.JS.\n     * \n     * @param {DOM Element} custom The container for our custom DOM elements.\n     * @param {JSON Array}  points The start and end points for our linear gradient.\n     */\n    _Draw(custom, points)\n    {\n        var elements = custom.selectAll('custom.elem');\n        var helper = new Konva.Group({\n            x: 0, y: 0\n        });\n        elements.each(function() {\n            var node = d3.select(this);\n\n            var gradientHeight = parseFloat(node.attr('gradientHeight')),\n                iconSize = parseFloat(node.attr('size')),\n                x = parseFloat(node.attr('x')),\n                y = parseFloat(node.attr('y'));\n\n            console.log('x: ' + x);\n\n            var icon = new Konva.Text({\n                text: node.attr('icon'),\n                fontSize: iconSize,\n                fontFamily: '\"Font Awesome 5 Free\"',\n                fontStyle: '900',\n                x: x,\n                y: y,\n                fillLinearGradientStartPoint: points[0],\n                fillLinearGradientEndPoint: points[1],\n                fillLinearGradientColorStops: [0, node.attr('fillStyle'), \n                    gradientHeight, node.attr('fillStyle'), \n                    gradientHeight, node.attr('remainderColor'), \n                    1, node.attr('remainderColor')]\n            });\n           \n            icon.rotate(-node.attr('angleOffset'));\n            helper.add(icon)\n        });\n        this._group.add(helper);\n    }\n}\n\nexport { IconBarChart };"]},"metadata":{},"sourceType":"module"}